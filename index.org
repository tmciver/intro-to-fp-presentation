#+TITLE: An Introduction to Functional Programming
#+OPTIONS: toc:1, num:nil
#+REVEAL_ROOT: https://cdn.jsdelivr.net/npm/reveal.js@3.8.0
#+REVEAL_THEME: moon

* What is Functional Programming?

** 
It's a bit hard to define, but let's give it a go.

** 
#+begin_quote
"functional programming can be viewed as a /style/ of programming in which the basic method of computation is the application of functions to arguments."

-- Graham Hutton, author of "Programming in Haskell"
#+end_quote

#+ATTR_REVEAL: :frag (appear)
There must be more to the story than that . . .

** 
#+BEGIN_QUOTE
# #+ATTR_HTML: :alt Wikipedia Logo :title Wikipedia Logo
# [[file:./img/220px-Wikipedia-logo-v2.svg.png]]
"Functional programming is a programming paradigm [...] that treats computation as the evaluation of mathematical functions and avoids changing-state and mutable data."

-- Wikipedia
#+END_QUOTE

** First-class Functions
#+ATTR_REVEAL: :frag (appear)
- Functional programming languages are often said to be those where functions are "first class".
- This means that functions are values like any other and can therefore be passed as arguments to other functions or returned from functions.

** First-Class Function Examples: JavaScript
#+HEADER: :exports both
#+begin_src js :results pp
setTimeout(function() {
  console.log("hello");
}, 3000);
#+end_src

#+HEADER: :exports both
#+begin_src js :results pp
var greeter = function(greeting) {
  return function(name) {
    console.log(greeting + ", " + name);
  };
}
var helloGreeter = greeter("Hello")
helloGreeter("FP fans!")
#+end_src

** First-Class Functions Enable Higher-Order Functions
#+begin_src php
// PHP
function map(callable $f, array $l) {
  $result = [];
  foreach ($l as $v) {
    $result[] = $f($v);
  }
  return $result;
}

$inc = function($i) {
  return $i + 1;
};
map($inc, [1, 2, 3]);
// [2, 3, 4]
#+end_src

** Pure Functions
#+ATTR_REVEAL: :frag (appear)
- Give the same output for a given set of inputs
- Have no side effects

** Pure Functions
These features give the following benefits:
#+ATTR_REVEAL: :frag (appear)
- Referential Transparency: a function call can be replaced by its value.
- Memoization potential
- Independent expressions can be run in parallel, i.e., they are automatically thread safe.
- The compiler is free to reorder or combine expressions.

** Using Pure Functions Leads to Purely Functional Programming
#+begin_quote
"purely functional programming usually designates a programming paradigm [...] that treats all computation as the evaluation of mathematical functions. Purely functional programming may also be defined by forbidding changing-state and mutable data."

-- Wikipedia
#+end_quote

* Versus Imperative Programming

** Functional Programming Is An Example of the Declarative Paradigm
#+ATTR_REVEAL: :frag (appear)
- It is based on the use of expressions or declarations
- contrasts with the imperative paradigm (the use of statements to change program state)

** Example: imperative
#+HEADER: :exports both
#+BEGIN_SRC python :results pp
# Python
chars = ['a', 'b', 'c']
upper_chars = []
for c in chars:
  upper_chars.append(c.upper())

return upper_chars
#+END_SRC
#+RESULTS:

** Example: functional
#+HEADER: :exports both
#+BEGIN_SRC python :results pp
# Python
chars = ['a', 'b', 'c']
upper_chars = [c.upper() for c in chars]

return upper_chars
#+END_SRC

#+RESULTS:

** Example: expressions vs. statements
In imperative languages, ~if~ / ~else~ is a statement:
#+begin_src java
// Java
String msg = "";
if (isMoving) {
  msg = "We're moving!";
} else {
  msg = "We're stopped.";
}
#+end_src
In functional languages, it's an expression.
#+begin_src scala
// Scala
val msg: String = if (isMoving)
                    "We're moving!"
                  else "We're stopped."
#+end_src

** Example: Factoring
#+begin_src python
// Python
in1 = read("some-file.txt")
write("some-file.txt", in1 + "new stuff.")
in2 = read("some-file.txt")
#+end_src

#+ATTR_REVEAL: :frag (appear)
#+begin_src haskell
-- Haskell
doIt = do
  in1 <- readFile("some-file.txt")
  writeFile("some-file.txt", in1 ++ "new stuff.")
  in2 <- readFile("some-file.txt")
  return in2
#+end_src

#+ATTR_REVEAL: :frag (appear)
#+begin_src haskell
-- Haskell
readSomeFile = readFile("some-file.txt")
doIt = do
  in1 <- readSomeFile
  writeFile("some-file.txt", in1 ++ "new stuff.")
  in2 <- readSomeFile
  return in2
#+end_src

* What is it Good For?
#+ATTR_REVEAL: :frag (appear)
- [[https://www.wired.com/2016/09/computer-scientists-close-perfect-hack-proof-code/][Hack-proof code]]?
- Property-based testing
- Computer-assisted optimizations
- Computer-assisted parallelization

* What is it Good For?
Whole classes of bugs become /impossible/.
[[file:./img/dotnet-try-round-bug-scaled.png]]

* Examples

* Uses in Industry
- Facebooks Spam Filters Written in Haskell
- WhatsApp Written in Erlang
- Some of Twitter (what parts?) Written in Scala
- Jane Street uses OCaml
- Github uses Haskell for "semantic" application

* Conclusion
